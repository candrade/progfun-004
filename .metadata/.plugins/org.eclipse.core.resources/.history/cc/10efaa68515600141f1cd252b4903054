package patmat

import common._

object HuffmanTest {
  abstract class CodeTree
  case class Fork(left: CodeTree, right: CodeTree, chars: List[Char], weight: Int) extends CodeTree
  case class Leaf(char: Char, weight: Int) extends CodeTree

  def weight(tree: CodeTree): Int = tree match {
    case Fork(l, r, cs, w) => w
    case Leaf(c, w) => w
  }

  def chars(tree: CodeTree): List[Char] = tree match {
    case Fork(l, r, cs, w) => cs
    case Leaf(c, w) => List(c)
  }

  def makeCodeTree(left: CodeTree, right: CodeTree) =
    Fork(left, right, chars(left) ::: chars(right), weight(left) + weight(right))
  
  def insert[T](comparator: (T, T) => Boolean)(x: T, xs: List[T]): List[T] = xs match {
    case List() => List(x)
    case y :: ys =>
      if (comparator(x, y)) x :: xs
      else y :: insert(comparator)(x, ys)
  }
	
  def count(c: Char, acc: List[(Char, Int)]): List[(Char, Int)] = acc match {
    case Nil => List((c, 1))
    case y :: ys =>
      if (c == y._1) (c, y._2 + 1) :: ys
      else y :: count(c, ys)
  }
  def times(chars: List[Char]): List[(Char, Int)] = chars match {
    case Nil => List()
    case x :: xs => count((x, 1), times(xs))
  }

	times(List('a','a','z','z','z','z','a','b','c','b'))

	def leafListInsert = insert[Leaf]((l1, l2) => l1.weight <= l2.weight) _
  def makeOrderedLeafList(freqs: List[(Char, Int)]): List[Leaf] = freqs match {
  	case Nil => List()
  	case y :: ys =>
  		leafListInsert(Leaf(y._1, y._2), makeOrderedLeafList(ys))
  }
                                              
	def singleton(trees: List[CodeTree]): Boolean = trees match {
    case y :: Nil => true
    case _ => false
  }

	def codeTreeInsert = insert[CodeTree]((t1, t2) => weight(t1) <= weight(t2)) _
  def combine(trees: List[CodeTree]): List[CodeTree] = trees match {
    case Nil => Nil
    case x :: y :: rest => codeTreeInsert(makeCodeTree(x, y), rest)
    case y :: Nil => List(y)
  }

	val leaflist = List(Leaf('e', 1), Leaf('t', 2), Leaf('x', 4))
	val combined = combine(leaflist)
	//val finalCombined = combine(combined)
    
  def until(t: List[CodeTree] => Boolean, c: List[CodeTree] => List[CodeTree])(ts: List[CodeTree]): List[CodeTree] =
    if (t(ts)) ts
    else until(t, c)(c(ts))

  def createCodeTree(chars: List[Char]): CodeTree = chars match {
    case List(x, _*) =>
      until(singleton, combine)(makeOrderedLeafList(times(chars))).head
    case Nil => Leaf('0', 0)
  }
  
  def decode(tree: CodeTree, bits: List[Bit]): List[Char] = {
    def step(subtree: CodeTree, xs: List[Bit], acc: List[Char]): List[Char] = subtree match {
      case Fork(l, r, cs, w) => step(if (xs.head == 0) l else r, xs.tail, acc)
      case Leaf(c, w) => {
      	val next = acc ::: List(c)
      	if (xs.isEmpty) next
      	else step(tree, xs, next)
      }
    }
    
    step(tree, bits, List())
  }
  
  def contains(char: Char, chars: List[Char]): Boolean =
  	if (chars.isEmpty) false
  	else if (chars.head == char) true
  	else contains(char, chars.tail)
  	
  def encode(tree: CodeTree)(text: List[Char]): List[Bit] = {
    def step(subtree: CodeTree, xs: List[Char], acc: List[Bit]): List[Bit] = subtree match {
      case Fork(l, r, cs, w) =>
      	if (contains(xs.head, chars(l))) step(l, xs, acc ::: List(0))
      	else step(r, xs, acc ::: List(1))
      case Leaf(c, w) => xs match {
      	case y :: Nil => acc
      	case _ => step(tree, xs.tail, acc)
      }
    }
    
    step(tree, text, List())
  }
  
  val easyTest = "ababaz".toList
  val easyResult = times(easyTest)
  val orderedEasyResult = makeOrderedLeafList(easyResult)
  val easyCodeTree = createCodeTree(easyTest)
  
  val medTest = "hello world".toList
  val medResult = times(medTest)
  val orderedMedResult = makeOrderedLeafList(medResult)
  val medCodeTree = createCodeTree(medTest)

	val exceptionTest = createCodeTree("".toList)
	val easyEncodedTest = encode(easyCodeTree)(easyTest)
	val easyDecodedTest = decode(easyCodeTree, easyEncodedTest).mkString
	
	val medEncodedTest = encode(medCodeTree)(medTest)
	val medDecodedTest = decode(medCodeTree, medEncodedTest).mkString

  val hardTest = "Because the Java application is run from within a Map-Reduce job".toList
  val hardCodeTree = createCodeTree(hardTest)
  val hardEncodedTest = encode(hardCodeTree)(hardTest)
  val hardDecodedTest = decode(hardCodeTree, hardEncodedTest).mkString
            
	type Bit = Int
  
  val frenchCode: CodeTree = Fork(Fork(Fork(Leaf('s',121895),Fork(Leaf('d',56269),Fork(Fork(Fork(Leaf('x',5928),Leaf('j',8351),List('x','j'),14279),Leaf('f',16351),List('x','j','f'),30630),Fork(Fork(Fork(Fork(Leaf('z',2093),Fork(Leaf('k',745),Leaf('w',1747),List('k','w'),2492),List('z','k','w'),4585),Leaf('y',4725),List('z','k','w','y'),9310),Leaf('h',11298),List('z','k','w','y','h'),20608),Leaf('q',20889),List('z','k','w','y','h','q'),41497),List('x','j','f','z','k','w','y','h','q'),72127),List('d','x','j','f','z','k','w','y','h','q'),128396),List('s','d','x','j','f','z','k','w','y','h','q'),250291),Fork(Fork(Leaf('o',82762),Leaf('l',83668),List('o','l'),166430),Fork(Fork(Leaf('m',45521),Leaf('p',46335),List('m','p'),91856),Leaf('u',96785),List('m','p','u'),188641),List('o','l','m','p','u'),355071),List('s','d','x','j','f','z','k','w','y','h','q','o','l','m','p','u'),605362),Fork(Fork(Fork(Leaf('r',100500),Fork(Leaf('c',50003),Fork(Leaf('v',24975),Fork(Leaf('g',13288),Leaf('b',13822),List('g','b'),27110),List('v','g','b'),52085),List('c','v','g','b'),102088),List('r','c','v','g','b'),202588),Fork(Leaf('n',108812),Leaf('t',111103),List('n','t'),219915),List('r','c','v','g','b','n','t'),422503),Fork(Leaf('e',225947),Fork(Leaf('i',115465),Leaf('a',117110),List('i','a'),232575),List('e','i','a'),458522),List('r','c','v','g','b','n','t','e','i','a'),881025),List('s','d','x','j','f','z','k','w','y','h','q','o','l','m','p','u','r','c','v','g','b','n','t','e','i','a'),1486387)
  val secret: List[Bit] = List(0,0,1,1,1,0,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,1)

  val decodedSecret = decode(frenchCode, secret).mkString
  
  
  
  type CodeTable = List[(Char, List[Bit])]
  
  def mergeCodeTables(a: CodeTable, b: CodeTable): CodeTable = a match {
    case Nil => b
    case x :: xs => x :: mergeCodeTables(xs, b)
  }
  
  def convert(tree: CodeTree): CodeTable = {
    def build(subTree: CodeTree, acc: List[Bit]): CodeTable = subTree match {
      case Fork(l, r, cs, w) =>
        mergeCodeTables(build(l, acc ::: List(0)), build(r, acc ::: List(1)))
      case Leaf(c, w) => List((c, acc))
    }
    
    build(tree, List())
  }
  
  def codeBits(table: CodeTable)(char: Char): List[Bit] = table match {
    case Nil => List()
    case x :: xs =>
      if (x._1 == char) x._2
      else codeBits(xs)(char)
  }
  
  def quickEncode(tree: CodeTree)(text: List[Char]): List[Bit] = {
    def generate(t: CodeTable, xs: List[Char]): List[Bit] = xs match {
      case Nil => Nil
      case x :: xs1 => codeBits(t)(x) ::: generate(t, xs1)
    }
    
    generate(convert(tree), text)
  }
  
  val tableA = List(('a', List(0,0,1)), ('b', List(0,1,0)), ('c', List(0,1,1)))
  val tableB = List(('d', List(1,0,0)), ('e', List(1,0,1)), ('f', List(1,1,1)))
  
  mergeCodeTables(tableA, tableB)
  
  val easyCodeTable = convert(easyCodeTree)
  
  val medCodeTable = convert(medCodeTree)
                                                   
  val bitsForA = codeBits(easyCodeTable)('a')
  val bitsForH = codeBits(medCodeTable)('h')
  val easyQuickEncoded = quickEncode(easyCodeTree)(easyTest)
  val medQuickEncoded = quickEncode(medCodeTree)(medTest)
  val hardQuickEncoded = quickEncode(hardCodeTree)(hardTest)
	val easyQuickDecoded = decode(easyCodeTree, easyQuickEncoded).mkString
	val medQuickDecoded = decode(medCodeTree, medQuickEncoded).mkString
	val hardQuickDecoded = decode(hardCodeTree, hardQuickEncoded).mkString
}